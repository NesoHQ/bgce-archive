# Class 42 : ‚ú® Complex And Beautiful Go Routine

## üåÄ Goroutine

- **Lightweight thread** / **Virtual thread**
- **Logically thread** ‡¶è‡¶∞ ‡¶Æ‡¶§‡ßã ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá
- Concurrently ‡¶Ö‡¶®‡ßá‡¶ï‡¶ó‡ßÅ‡¶≤‡ßã function execute ‡¶ï‡¶∞‡ßá
- **Go Runtime** ‡¶è‡¶ï‡ßá manage ‡¶ï‡¶∞‡ßá

## üõ†Ô∏è Creating a Goroutine

‡¶ï‡ßã‡¶®‡ßã function ‡¶è‡¶∞ ‡¶Ü‡¶ó‡ßá `go` keyword ‡¶≤‡¶ø‡¶ñ‡ßá ‡¶¶‡¶ø‡¶≤‡ßá ‡¶∏‡ßá‡¶ü‡¶æ _goroutine_ ‡¶π‡ßü‡•§

### üí° Example

```go
package main

import (
    "fmt"
    "time"
    )

var a = 10

const p = 11

func printHello(num int) {
	fmt.Println("Hello Habib", num)
}

func main() {
	go printHello(1)

	go printHello(2)

	go printHello(3)

	go printHello(4)

	go printHello(5)

	fmt.Println(a, " ", p)

	time.Sleep(5 * time.Second)
}
```

‡¶è‡¶á Go ‡¶ï‡ßã‡¶°‡ßá ‡¶è‡¶ï‡¶ü‡¶æ `printHello` ‡¶®‡¶æ‡¶Æ‡ßá‡¶∞ ‡¶´‡¶æ‡¶Ç‡¶∂‡¶® ‡¶Ü‡¶õ‡ßá, ‡¶Ø‡ßá‡¶ü‡¶æ `"Hello Habib"` ‡¶≤‡¶ø‡¶ñ‡ßá ‡¶∏‡¶æ‡¶•‡ßá ‡¶è‡¶ï‡¶ü‡¶æ ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶™‡ßç‡¶∞‡¶ø‡¶®‡ßç‡¶ü ‡¶ï‡¶∞‡ßá‡•§

`main()` ‡¶´‡¶æ‡¶Ç‡¶∂‡¶®‡ßá ‡¶è‡¶á ‡¶´‡¶æ‡¶Ç‡¶∂‡¶®‡¶ü‡¶æ ‡ß´ ‡¶¨‡¶æ‡¶∞ _goroutine_ ‡¶¶‡¶ø‡ßü‡ßá ‡¶ö‡¶æ‡¶≤‡¶æ‡¶®‡ßã ‡¶π‡ßü‡ßá‡¶õ‡ßá

‡¶∏‡¶¨‡¶ó‡ßÅ‡¶≤‡¶æ _goroutine_ ‡¶Ø‡ßá‡¶® ‡¶ï‡¶æ‡¶ú ‡¶∂‡ßá‡¶∑ ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá, ‡¶§‡¶æ‡¶á ‡¶∂‡ßá‡¶∑‡ßá `time.Sleep(5 * time.Second)` ‡¶¶‡¶ø‡ßü‡ßá ‡ß´ ‡¶∏‡ßá‡¶ï‡ßá‡¶®‡ßç‡¶° ‡¶™‡ßç‡¶∞‡ßã‡¶ó‡ßç‡¶∞‡¶æ‡¶Æ‡¶ü‡¶æ‡¶ï‡ßá ‡¶Ö‡¶™‡ßá‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡¶æ‡¶®‡ßã ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§

## üì¶ How gorouitne works Internally

**Goroutine** ‡¶ï‡ßÄ‡¶≠‡¶æ‡¶¨‡ßá ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá ‡¶¨‡ßÅ‡¶ù‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶Ü‡¶Æ‡¶æ‡¶¶‡ßá‡¶∞ ‡¶è‡¶ï‡¶ü‡¶ø Go program ‡¶è‡¶∞ _compilation_, _execution phase_ ‡¶è‡¶¨‡¶Ç _Thread_ ‡¶≠‡¶æ‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶¨‡ßÅ‡¶ù‡¶§‡ßá ‡¶π‡¶¨‡ßá‡•§

### üîß Compilation Phase of Go Program

Go program ‡¶ï‡ßá compile ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶®‡¶ø‡¶ö‡ßá‡¶∞ command ‡¶ü‡¶ø ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü

```go
go build main.go
```

- ‡¶è‡¶§‡ßá ‡¶è‡¶ï‡¶ü‡¶ø binary executable file ‡¶§‡ßà‡¶∞‡¶ø ‡¶π‡¶¨‡ßá (_Linux_ ‡¶è `main`, _Windows_ ‡¶è `main.exe`)
- Binary executable file ‚Üí Code Segment
- Code Segment ‚Üí `const` (read only)
  ‚Üí **functions**
- `main` binary executable file store ‚Üí **HDD**

```plaintext
                        **Code Segment**

			p = 11
			printHello = printHello() {...}
			main = main() {...}

```

### üöÄ Execution Phase of Go Program

Binary executable file run ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø command -

```bash
./main
```

- Binary executable file load ‚Üí RAM
- RAM Memory Layout ‚Üí Code Segment, Data Segment, Stack, Heap
- `main` program ‚Üí Process create ‡¶π‡ßü

| Segment      | Purpose                                   | Size / Behavior                   |
| ------------ | ----------------------------------------- | --------------------------------- |
| Code Segment | compiled machine code (functions)         | Fixed size                        |
| Data Segment | global & static variables                 | Fixed or small                    |
| Heap         | dynamically allocated data (`make`, etc.) | Grows **upward**                  |
| Stack        | function call info, local vars            | Grows **downward**, \~8MB (Linux) |

> ‡¶Ø‡ßá ‡¶ï‡ßã‡¶®‡¶ì programming language (‡¶Ø‡ßá‡¶Æ‡¶® C, C++, Go, Rust) ‡¶è‡¶∞ ‡¶™‡ßç‡¶∞‡ßã‡¶ó‡ßç‡¶∞‡¶æ‡¶Æ ‡¶Ø‡¶ñ‡¶® compile ‡¶π‡ßü‡ßá binary (.exe / .out) ‡¶§‡ßá convert ‡¶π‡ßü ‡¶è‡¶¨‡¶Ç execution ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶π‡ßü, ‡¶§‡¶ñ‡¶® ‡¶è‡¶ï‡¶ü‡¶æ process ‡¶§‡ßà‡¶∞‡¶ø ‡¶π‡ßü ‡¶è‡¶¨‡¶Ç ‡¶∏‡ßá‡¶á process ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø memory ‡¶§‡ßá _Code Segment, Data Segment, Stack, Heap_ ‡¶•‡¶æ‡¶ï‡ßá‡•§

### üîç RAM Memory Layout Visualization

```plaintext
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       Heap               ‚îÇ ‚Üê Grows Upward
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ     Stack (Top ‚Üì)        ‚îÇ ‚Üê Grows Downward
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ     Data Segment         ‚îÇ ‚Üê Initialized global/static variables
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ     Code Segment         ‚îÇ ‚Üê Machine Instructions
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### ‚öôÔ∏è Program Execution Process Visualization

```plaintext

HDD ‚ûú OS Loader ‚ûú RAM ‚ûú CPU Executes

üìÅ HDD (Hard Disk)
‚îÇ
‚îÇ  ‚Üí Executable File (.exe, .out, etc.)
‚îÇ
‚ñº
üì• Loader (Operating System)
‚îÇ
‚îÇ  ‚Üí Loads program into RAM
‚îÇ
‚ñº
üß† RAM (Main Memory)
‚îÇ
‚îú‚îÄ‚îÄ üìÑ Code Segment        ‚Üí compiled machine code (instructions)
‚îÇ
‚îú‚îÄ‚îÄ üóÉÔ∏è Data Segment        ‚Üí global & static variables
‚îÇ
‚îú‚îÄ‚îÄ üì¶ Heap Segment        ‚Üí dynamic memory (malloc/new)
‚îÇ
‚îú‚îÄ‚îÄ üìö Stack Segment       ‚Üí function calls, local variables
‚îÇ
‚ñº
‚ö° CPU (Processor)
   ‚îú‚îÄ‚îÄ Fetch ‚Üí Decode ‚Üí Execute instructions
   ‚îú‚îÄ‚îÄ Uses Registers (like AL, BL, etc.)
   ‚îî‚îÄ‚îÄ Uses Stack Pointer (SP), Base Pointer (BP)
```

### üñ•Ô∏è Process & Thread

- Process initially ‡¶è‡¶ï‡¶ü‡¶ø Thread ‡¶•‡¶æ‡¶ï‡ßá ‚Üí Deafult Thread / Main Thread
- Thread ‡¶ï‡ßá OS ‡¶è‡¶∞ kernel execute ‡¶ï‡¶∞‡¶≤‡ßá ‚Üí Stack execute ‡¶π‡ßü
- Stack execute ‚Üí Stack frame create & execute ‡¶π‡ßü

### üåÄ Go Runtime = A Mini OS or Virtual Operating System

Go program ‚Üí Run ‚Üí `main` binary load ‚Üí Code Segment

> ‚öôÔ∏è **`main` Binary ‚Äì More Than Just Code Segment**
>
> - ‡¶∂‡ßÅ‡¶ß‡ßÅ code segment ‡¶®‡ßü
> - ‡¶Ü‡¶∞‡¶ì ‡¶Ö‡¶®‡ßá‡¶ï binary ‡¶•‡¶æ‡¶ï‡ßá
> - code segment ‡¶∂‡ßÅ‡¶ß‡ßÅ ‡¶è‡¶ï‡¶ü‡¶æ ‡¶Ö‡¶Ç‡¶∂ ‡¶Æ‡¶æ‡¶§‡ßç‡¶∞

- Thread execute ‚Üí Process start
- Process ‚Üí Virtual computer
- Go Runtime ‚Üí Virtual Operating System
- Process start ‚Üí Go Runtime execute

#### üß© Go Runtime Code Execute

- Stack ‚Üí 8MB Stack (main stack) ‚Üí Stack Frame create
- main thread execute ‡¶ï‡¶∞‡ßá ‚Üí Go runtime

Go Runtime initialize ‡¶ï‡¶∞‡ßá -

- **1. Go Routine Scheduler**
- **2. Heap Allocator**
- **3. Garbage Collector**
- **4. Logical Processors**

#### Go Routine Scheduler

_OS Kernel scheduler_ ‚Üí Process schedule, Concurrency, Parallelism handle ‡¶ï‡¶∞‡ßá‡•§

_Go Routine Scheduler_ ‡¶ì Real OS Kernel Scheduler ‡¶è‡¶∞ ‡¶Æ‡¶§‡ßã ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá‡•§

#### Logical Processors

> üîÅ _Recap_
>
> - [CPU ‡¶ï‡ßÄ‡¶≠‡¶æ‡¶¨‡ßá Code execute ‡¶ï‡¶∞‡ßá](https://nesohq.github.io/bgce-archive/interview-qna/class-wise/golang034-breaking-the-cpu-and-process/index.html)

- OS ‡¶è‡¶∞ ‡¶≠‡¶ø‡¶§‡¶∞ ‚Üí virtual processors (vCPU) create ‡¶π‡ßü
- CPU ‡¶§‡ßá ‡¶Ø‡ßá ‡¶ï‡ßü‡¶ü‡¶ø vCPU (virtual CPU / logical Processor) ‡¶•‡¶æ‡¶ï‡ßá ‚Üí Go Runtime ‡¶∏‡ßá ‡¶ï‡ßü‡¶ü‡¶ø logical processor create ‡¶ï‡¶∞‡ßá
- ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø logical processor ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‚Üí OS ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ OS Thread create ‡¶ï‡¶∞‡ßá
  - CPU 2 core ‚Üí 4 vCPU
  - Go Runtime initilize ‡¶ï‡¶∞‡ßá ‚Üí 4 logical processors
  - 4 logical processors ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‚Üí OS ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ 4 OS Thread create ‡¶ï‡¶∞‡ßá
  - 4 OS Thread ‚Üí 4 stack
  - Total threads in process ‚Üí 4 (OS thread) + 1 (main thread) ‚Üí 5 threads
  - OS kernel ‚Üí 5 threads ‡¶ï‡ßá track ‡¶ï‡¶∞‡ßá
  - 1 main thread ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‚Üí 1 main stack
  - 4 supporting thread ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‚Üí 4 supporting stack
- go runtime kernel ‚Üí go routine schedule ‡¶ï‡¶∞‡ßá
  - 4 thread ‚Üí 10 goroutine execute ‡¶ï‡¶∞‡ßá concurrency follow ‡¶ï‡¶∞‡ßá

### üß† Go Runtime: OS Thread, Scheduler, and Logical Processor Mapping

```plaintext
                    üåÄ Go Runtime Scheduler
                             ‚îÇ
                             ‚ñº
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
|                   Logical Processors (P)           |
|‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ|
|      P1               P2              P3           |
|        										     |
|   [G1, G4, G6]     [G2, G5]        [G3, G7, G8]    |
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      ‚îÇ               ‚îÇ              ‚îÇ
      ‚ñº               ‚ñº              ‚ñº
  Assigned to     Assigned to    Assigned to
      ‚îÇ               ‚îÇ              ‚îÇ
      ‚ñº               ‚ñº              ‚ñº
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
|             OS Threads (M)                 |
|‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ |
|     M1             M2             M3       |
|   (running)     (running)      (idle)      |
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      ‚îÇ               ‚îÇ
      ‚ñº               ‚ñº
   üñ•Ô∏è CPU Core 1     üñ•Ô∏è CPU Core 2

```

> Go runtime, OS Thread ‡¶ï‡ßÄ‡¶≠‡¶æ‡¶¨‡ßá create ‡¶ï‡¶∞‡¶§‡ßá ‡¶π‡ßü ‡¶∏‡ßá‡¶ü‡¶ø handle ‡¶ï‡¶∞‡ßá‡•§

> Go runtime ‡¶∂‡ßÅ‡¶∞‡ßÅ‡¶§‡ßá‡¶á ‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ‡ßá‡¶∞ vCPU (logical core) ‡¶Ö‡¶®‡ßÅ‡¶Ø‡¶æ‡ßü‡ßÄ Logical Processor (P) ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßá‡•§

- Go Runtime ‡¶®‡¶ø‡¶ú‡ßá‡¶á ‡¶è‡¶ï‡¶ü‡¶ø kernel ‡¶è‡¶∞ ‡¶Æ‡¶§‡ßã ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá
- ‡¶è‡¶á "kernel" ‡¶è‡¶∞ scheduler ‡¶•‡¶æ‡¶ï‡ßá
- Scheduler, Goroutine ‡¶ó‡ßÅ‡¶≤‡ßã‡¶ï‡ßá execute ‡¶ï‡¶∞‡¶§‡ßá OS thread ‡¶ï‡ßá ‡¶ï‡¶æ‡¶ú ‡¶≠‡¶æ‡¶ó ‡¶ï‡¶∞‡ßá ‡¶¶‡ßá‡ßü
- OS Thread ‡¶ó‡ßÅ‡¶≤‡ßã‡¶á CPU ‡¶§‡ßá ‡¶¨‡¶∏‡ßá goroutine ‡¶ó‡ßÅ‡¶≤‡ßã execute ‡¶ï‡¶∞‡ßá
- Go Scheduler ‡¶†‡¶ø‡¶ï ‡¶ï‡¶∞‡ßá ‡¶ï‡ßã‡¶® goroutine ‡¶ï‡¶ñ‡¶® execute ‡¶π‡¶¨‡ßá
- Scheduler OS thread ‡¶è map ‡¶ï‡¶∞‡ßá thousands of goroutine efficiently ‡¶ö‡¶æ‡¶≤‡¶æ‡ßü

### üñ•Ô∏è Go Runtime Kernel & Goroutine Scheduling

```plaintext
                       üåÄ Go Runtime (Mini Kernel)
                               ‚îÇ
                               ‚ñº
                      üß† Go Routine Scheduler (Scheduler)
                               ‚îÇ
      -----------------------------------------------------
      |                       |                           |
      ‚ñº                       ‚ñº                           ‚ñº
  G1: Goroutine         G2: Goroutine               G3: Goroutine
 (Task 1)                 (Task 2)                     (Task 3)
      \_______________________|________________________/
                               ‚îÇ
                               ‚ñº
                    üì¶ Placed into P's Run Queue
                               ‚îÇ
                               ‚ñº
        üîÑ Scheduler decides which G to run on which M
                               ‚îÇ
      -----------------------------------------------------
      |                       |                          |
      ‚ñº                       ‚ñº                          ‚ñº
   üßµ M1: OS Thread        üßµ M2: OS Thread           üßµ M3: OS Thread
 (Executes Gs)          (Executes Gs)              (Executes Gs)
      |                       |                          |
      ‚ñº                       ‚ñº                          ‚ñº
   üñ•Ô∏è CPU Core 1          üñ•Ô∏è CPU Core 2             üñ•Ô∏è CPU Core 3


   ‚Üí G (goroutine)
   ‚Üí P (Processor)
   ‚Üí M (OS Thread)

```

> Programmer Goroutine create ‡¶ï‡¶∞‡ßá‡•§

#### üìàüßµ Effects of Excessive Goroutines in Go

- Scheduler notice ‡¶ï‡¶∞‡ßá ‚Üí excessive gorutines
- Go Runtime ‚Üí ‡¶™‡ßç‡¶∞‡ßü‡ßã‡¶ú‡¶® ‡¶Ö‡¶®‡ßÅ‡¶Ø‡¶æ‡ßü‡ßÄ logical processors & OS Thread create ‡¶ï‡¶∞‡ßá
- RAM full ‚Üí OS Thread create ‡¶ï‡¶∞‡¶æ possible ‡¶π‡ßü ‡¶®‡¶æ
- ‚ùå OS Thread ‚Üí ‚ùå Goroutine execution

> First ‡¶Ø‡ßá goroutine run ‡¶π‡ßü ‚Üí main goroutine

> main function execute ‡¶π‡ßü ‚Üí main goroutine ‡¶è

## üè† Goroutine's Home: Stack & Heap

Goroutine - mini thread / virtual thread / logical thread

‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø goroutine

- ‡¶è‡¶∞ **stack ‡¶•‡¶æ‡¶ï‡ßá heap** memory ‡¶è
- ‡¶∂‡ßÅ‡¶∞‡ßÅ‡¶§‡ßá ‡¶Æ‡¶æ‡¶§‡ßç‡¶∞ **2KB stack** ‡¶™‡¶æ‡ßü

### `main()` ‚Üí Main Goroutine

- Go ‡¶™‡ßç‡¶∞‡ßã‡¶ó‡ßç‡¶∞‡¶æ‡¶Æ ‡¶∞‡¶æ‡¶® ‡¶π‡¶≤‡ßá‡¶á `main()` function ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶π‡ßü
- ‡¶è‡¶ü‡¶ø‡¶á ‡¶™‡ßç‡¶∞‡¶•‡¶Æ goroutine - ‡¶Ø‡¶æ‡¶ï‡ßá ‡¶¨‡¶≤‡ßá **Main Goroutine**
- ‡¶∏‡¶¨ normal function call (‡¶Ø‡ßá‡¶Æ‡¶® `f()`, `g()`) ‡¶è‡¶∞ stack frame ‡¶§‡ßà‡¶∞‡¶ø ‡¶π‡ßü ‡¶è‡¶á ‡¶è‡¶ï‡¶á stack ‡¶è

### `go functionName()` ‚Üí New Goroutine

`go functionName()` ‡¶≤‡¶ø‡¶ñ‡¶≤‡ßá ‡¶§‡¶ñ‡¶® Go runtime:

- ‡¶®‡¶§‡ßÅ‡¶® goroutine ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßá
- ‡¶∏‡ßá‡¶ü‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ stack ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡ßá (initially 2KB)
- ‡¶è‡¶ü‡¶ø‡¶ï‡ßá scheduling queue ‡¶§‡ßá ‡¶¶‡ßá‡ßü

#### üñºÔ∏è Example

```go
var a = 10

const p = 11

func add(a, b int) {
  fmt.Println(a + b)
}

func printHello(num int) {
	fmt.Println("Hello Habib", num)

     add(2, 4)
}

func main() {
    var x int = 10

    fmt.Println("Hello", x)

    printHello(10)

    go printHello(1)

    go printHello(2)

    go printHello(3)

    go printHello(4)

    go printHello(5)

    fmt.Println(a, " ", p)

    time.Sleep(5 * time.Second)
}
```

**Main Goroutine**

- ‡¶è‡¶ñ‡¶æ‡¶®‡ßá `main()` ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø _main goroutine_ create ‡¶π‡¶¨‡ßá
- main goroutine ‡¶è `main()`, `printHello(10)` ‡¶è‡¶¨‡¶Ç `fmt.Println()` ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø Stack Frame create ‡¶π‡¶¨‡ßá
- ‡¶Ø‡¶¶‡¶ø Go program ‡¶è `init()` ‡¶•‡¶æ‡¶ï‡ßá ‡¶§‡¶¨‡ßá `init()` ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶ì Stack Frame, _main goroutine_ ‡¶è create ‡¶π‡¶¨‡ßá

**Other Goroutines**

- `printHello()` ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø Go runtime ‡ß´‡¶ü‡¶ø ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ goroutine ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶¨‡ßá
- `go printHello(1)` ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø Heap ‡¶è ‡¶Ø‡ßá goroutine create ‡¶π‡ßü ‡¶∏‡ßá‡¶ñ‡¶æ‡¶®‡ßá `printHello(1)`, `fmt.Println()` ‡¶è‡¶¨‡¶Ç `add(2, 4)` ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø Stack Frame create ‡¶π‡¶¨‡ßá
- ‡¶è‡¶ï‡¶á ‡¶≠‡¶æ‡¶¨‡ßá ‡¶Ö‡¶®‡ßç‡¶Ø goroutine ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø‡¶ì Stack Frame create ‡¶π‡¶¨‡ßá

**üîç ‡¶Ø‡¶¶‡¶ø 2KB Stack ‡¶Ø‡¶•‡ßá‡¶∑‡ßç‡¶ü ‡¶®‡¶æ ‡¶π‡ßü**

- ‚û°Ô∏è Go runtime automatically stack ‡¶è‡¶∞ size ‡¶¨‡ßú ‡¶ï‡¶∞‡ßá ‡¶¶‡ßá‡ßü (dynamic grow ‡¶ï‡¶∞‡ßá)

**üìà ‡¶ï‡¶ø‡¶≠‡¶æ‡¶¨‡ßá ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá?**

- _‡¶∂‡ßÅ‡¶∞‡ßÅ‡¶§‡ßá:_ **2KB**
- _‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞ ‡¶π‡¶≤‡ßá:_ **4KB**, **8KB**, **16KB**... ‚Üí ‡¶Ø‡¶§ ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞ ‡¶§‡¶§ ‡¶¨‡¶æ‡ßú‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá
- _‡¶∏‡¶∞‡ßç‡¶¨‡ßã‡¶ö‡ßç‡¶ö_: **1 GB** ‡¶™‡¶∞‡ßç‡¶Ø‡¶®‡ßç‡¶§

> Go runtime ‡¶™‡ßÅ‡¶∞‡¶æ stack copy ‡¶ï‡¶∞‡ßá ‡¶®‡¶§‡ßÅ‡¶® ‡¶¨‡ßú stack ‡¶è ‡¶®‡¶ø‡ßü‡ßá ‡¶Ø‡¶æ‡ßü, old stack ‡¶´‡ßá‡¶≤‡ßá ‡¶¶‡ßá‡ßü‡•§

> Go Runtime reallocate ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡•§

Heap ‡¶è‡¶∞ Stack ‡¶è ‡¶Ø‡ßá [SP, BP](https://nesohq.github.io/bgce-archive/interview-qna/class-wise/golang035-BP-SP/index.html) ‡¶•‡¶æ‡¶ï‡ßá ‡¶§‡¶æ ‡¶Æ‡ßÇ‡¶≤‡¶§ **Go Runtime ‡¶è‡¶∞ initialized logical processor** ‡¶è‡¶∞ SP, BP, return address etc.

```

                    üßµ Goroutines & Their Stack Memory

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Goroutine 1 (main)           ‚îÇ Goroutine 2 (printHello 1)  ‚îÇ Goroutine 3 (printHello 2)  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Stack:                       ‚îÇ Stack:                      ‚îÇ Stack:                      ‚îÇ
‚îÇ - main()                     ‚îÇ - printHello(1)             ‚îÇ - printHello(2)             ‚îÇ
‚îÇ - printHello(10)             ‚îÇ - fmt.Println()             ‚îÇ - fmt.Println()             ‚îÇ
‚îÇ - fmt.Println()              ‚îÇ - add(2, 4)                 ‚îÇ - add(2, 4)                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Goroutine 4 (printHello 3)  ‚îÇ Goroutine 5 (printHello 4)  ‚îÇ Goroutine 6 (printHello 5)   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Stack:                      ‚îÇ Stack:                      ‚îÇ Stack:                       ‚îÇ
‚îÇ - printHello(3)             ‚îÇ - printHello(4)             ‚îÇ - printHello(5)              ‚îÇ
‚îÇ - fmt.Println()             ‚îÇ - fmt.Println()             ‚îÇ - fmt.Println()              ‚îÇ
‚îÇ - add(2, 4)                 ‚îÇ - add(2, 4)                 ‚îÇ - add(2, 4)                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

```

> Main goroutine ‡¶∂‡ßá‡¶∑ ‡¶π‡¶≤‡ßá‡¶á ‡¶™‡ßÅ‡¶∞‡ßã program ‡¶∂‡ßá‡¶∑,
> ‡¶§‡¶æ‡¶á ‡¶Ö‡¶®‡ßç‡¶Ø goroutine ‡¶ö‡¶æ‡¶≤‡¶æ‡¶§‡ßá ‡¶ö‡¶æ‡¶á‡¶≤‡ßá main goroutine ‡¶ï‡ßá ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶∏‡¶Æ‡ßü ‡¶¨‡¶æ‡¶Å‡¶ö‡¶ø‡ßü‡ßá ‡¶∞‡¶æ‡¶ñ‡¶§‡ßá ‡¶π‡¶¨‡ßá ‚úÖ

**üí• When & How _Main Thread_, _Go Runtime_ & _Main Goroutine_ Get Destroyed**

> main thread ‚â† main goroutine

| Component            | Destruction Point                      |
| -------------------- | -------------------------------------- |
| **Main Goroutine**   | Ends when `main()` returns or panics   |
| **Main Thread**      | Exits after main goroutine ends        |
| **Go Runtime**       | Terminates when main goroutine ends    |
| **Other Goroutines** | Force-killed when main goroutine exits |

> goroutine ‡¶ó‡ßÅ‡¶≤‡ßã ‡¶∂‡ßá‡¶∑ ‡¶™‡¶∞‡ßç‡¶Ø‡¶®‡ßç‡¶§ execute ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø `main()` ‡¶ï‡ßá block ‡¶ï‡¶∞‡ßá ‡¶∞‡¶æ‡¶ñ‡¶æ ‡¶Ø‡¶æ‡ßü ‡¶Ø‡ßá‡¶Æ‡¶®:
>
> - `time.Sleep()`
> - `sync.WaitGroup`
> - `select {}` (infinite block)

## üßµ Thread vs Goroutine

| Feature               | **Thread**                  | **Goroutine**                                |
| --------------------- | --------------------------- | -------------------------------------------- |
| **Definition**        | OS-level execution unit     | Go‚Äôs lightweight concurrent execution unit   |
| **Created By**        | Operating System            | Go Runtime Scheduler                         |
| **Memory Usage**      | \~1 MB stack (fixed)        | Starts with \~2 KB stack (grows dynamically) |
| **Creation Cost**     | High (involves system call) | Very Low (simple runtime function)           |
| **Scheduling**        | Done by OS                  | Done by Go runtime (user-space scheduler)    |
| **Communication**     | Using shared memory, locks  | Using channels (safe and built-in)           |
| **Concurrency Limit** | Limited (few thousand max)  | Huge (millions possible)                     |
| **Blocking**          | Blocks entire thread        | Blocking one goroutine doesn‚Äôt block others  |
| **Context Switching** | Costly (kernel-level)       | Cheap (user-space context switch)            |
| **Portability**       | Depends on OS               | Cross-platform (managed by Go)               |

[**Author:** @nazma98
**Date:** 2025-06-24
**Category:** interview-qa/class-wise
]
